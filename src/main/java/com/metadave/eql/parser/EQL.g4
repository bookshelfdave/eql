grammar EQL;

stmts: connect_stmt? (query_stmt | index_stmt | get_stmt )*;

connect_stmt      :  CONNECT clusterName=ID? hps+=hostport (COMMA hps+=hostport)* SEMI;

// TODO: NOT REALLY A HOSTNAME REGEX!
hostport          : host=ID ':' port=INT;

index_stmt        : INDEX idx=ID WITH itype=ID EQUALS content=string_value SEMI;
get_stmt          : GET   idx=ID WITH itype=ID EQUALS content=string_value SEMI;

query_stmt        :  QUERY key=ID field_list?  aggregate_stmt? filter_stmt? return_stmt? sort_stmt? SEMI;

aggregate_stmt    : AGGREGATE aggregate_mappings;

aggregate_mappings : am+=aggregate_mapping (COMMA am+=aggregate_mapping)*;
aggregate_mapping  : (ID EQUALS funcall);

funcall           : funname=ID LPAREN field=ID RPAREN;

//aggregate min_price from resellers using min_price = min(resellers.price);

field_list        : LPAREN fields+=ID (COMMA fields+=ID)* RPAREN;

filter_stmt       :   'filter' filter_pred;

filter_pred       : name=ID '=' (intval=INT | stringval=string_value) filter_rest?
                    | LPAREN childpred=filter_pred RPAREN;

// as far as I can tell, you can't combine ANDs with ORs etc UNLESS
// you nest the bool filter
filter_rest :     (AND ands+=filter_pred)+
                  | (OR  ors+=filter_pred)+;
                  //TODO: just use !=? | (NOT filter_pred)*;

// antlr4 doesn't like "return" by itself, use "RETURNKW"
return_stmt       : RETURNKW size=INT? (FROM lower=INT)?;

sort_stmt         : SORT ON keys+=ID sorts+=ascdesc (COMMA keys+=ID sorts+=ascdesc)*;
ascdesc           : asc='asc' | desc='desc';

string_value: SINGLE_STRING | DOUBLE_STRING | DATA_CONTENT;



INDEX       :    'index';
SORT        :    'sort';
AGGREGATE   :    'aggregate';
CONNECT     :    'connect';
QUERY       :    'query';
ALL         :    'all';
GET         :    'get';
RETURNKW    :    'return';
FROM        :    'from';
WITH        :    'with';
ON          :    'on';
TO          :    'to';
AND         :    'and';
OR          :    'or';
NOT         :    'not';
AT          :    '@';
DOLLAR      :    '$';
SPLAT       :    '*';
COMMA       :    ',';
LSQUARE     :    '[';
RSQUARE     :    ']';
LPAREN      :    '(';
RPAREN      :    ')';
EQUALS      :    '=';
DOT         :    '.';
SEMI        :    ';';
ID          :       LOWER (UPPER | LOWER | DIGIT | '_' | '.')*;

fragment LOWER : 'a' .. 'z';
fragment UPPER : 'A' .. 'Z';

INT             :   DIGIT+;
fragment DIGIT  : '0' .. '9';

FLOAT       :       DIGIT+ DOT DIGIT*
                    | DOT DIGIT+
                       ;

// double quoted string
DOUBLE_STRING  :  '"' (ESC|.)*? '"';
fragment ESC : '\\"' | '\\\\' ;

// single quoted string
SINGLE_STRING  :  '\'' (SESC|.)*? '\'';
fragment SESC : '\\\'' | '\\\\' ;

// scissors op, dude riding a pterodactyl, drunken bird
DATA_CONTENT: '~%~' (DATA_ESC|.)*? '~%~';
fragment DATA_ESC: '\\~%~' | '\\~%~';


LINE_COMMENT  : '//' .*? '\r'? '\n' -> skip ;
COMMENT       : '/*' .*? '*/'       -> skip ;

// unicode space chars generated by http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AZs%3A%5D&g=
WS      :       (WSCHARS | Zs | Cc)+ -> channel(HIDDEN);

WSCHARS:
[ \t\r\n];

fragment Zs:
    '\u0020' |
    '\u3000' |
    '\u1680' |
    '\u2000'..'\u2006' |
    '\u2008'..'\u200A' |
    '\u205F' |
    '\u00A0' |
    '\u2007' |
    '\u202F';

fragment Cc:
    '\u0000'..'\u0008' |
    '\u000E'..'\u001F' |
    '\u007F'..'\u0084' |
    '\u0086'..'\u009F' |
    '\u0009'..'\u000D' |
    '\u0085';
